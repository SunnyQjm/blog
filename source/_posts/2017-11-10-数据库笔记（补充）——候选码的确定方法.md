---
layout:     post                    # 使用的布局（不需要改）
title:      数据库笔记（补充）——候选码的确定方法         # 标题
subtitle:                          #副标题
date:       2017-11-10              # 时间
author:     Ming.J                      # 作者
header-img: img/blog-header1.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 数据库
    - 学习
    - 笔记
---

> 写在前面：前面一堆都了解了解，重点在后面一个关于求候选码的算法（***要是题里面没有给主属性，就要通过这个方法求哪些是主属性，哪些不是了，所以还是挺实用的***）

>  **候选码**定义:  设K为关系模式R<U, F>的属性(组)，若K→<sup>F</sup>U，则称K为R的 **候选码**。
* 主码：若R<U , F>有多个候选码，则可以从中选定一个作为R的主码。
* 主属性：包含在任一个候选码中的属性，称作主属性。
* 非主属性：不包含在任一个候选码中的属性，称作非主属性(或非码属性)。
* 全码：关系模式的码由全部属性构成。

注: **码或者是某一函数依赖的左部, 或是一个属性组**。

> 引例：求出关系模式R<U, F>的所有候选码：
U={ A , B , C , D , E }
F={AB→C, B→D, C→E, EC→B, AC→B }

解： 验证AB是否码, 须证明  AB→<sup>F</sup>ABCDE是否成立?
∵AB→C(已知), 而AB→AB(自反), ∴AB → ABC(合并)
∵B→D(已知), ∴AB→AD(增广), ∴AB → ABCD(合并)
∵C→E(已知),  AB→C(已知),  ∴AB → E(传递)
   于是 AB → ABCDE(合并)

同理可证：AC也是一个候选码

### 上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集）

> 练习： 根据码的定义，求关系模式R<U, F>的所有候选码。
U={ A , B , C , D }， F={A→ B, C→B }

答：ACD

> 关于2NF的结论
1. 不存在非主属性的关系模式属于2NF。 （没有非主属性）
2. 全码关系模式属于2NF。 （没有非主属性）
3. 码只由一个属性组成的关系模式属于2NF。（不会有部分依赖）
4. 二目关系模式属于2NF。 （码或是一个属性，或是全码）
5. 若R属于1NF，但R不一定属于2NF。
例如,  关系模式 S(S#, SN, SD, DEAN, C#, G)

> 关于3NF的结论
1. 不存在非主属性的关系模式属于3NF。 （没有非主属性）
2. 全码关系模式属于3NF。 （没有非主属性）
3. 二目关系模式属于3NF。 （不会存在传递依赖）
4. 若R属于3NF，那么R也属于2NF。
（可证明，反证）
5. 若R属于2NF，但R不一定属于3NF。
例如，关系模式 S_SD(S#, SN, SD, DEAN)

> **BCNF**定义：关系模式R<U, F> ∈1NF，对于属性组X和Y，若X→Y且Y ∉ X时X必含有码，则R<U, F > ∈BCNF
* 由BCNF的定义，对于非平凡的函数依赖:  X  →  Y
  * X包含码，或者X本身就是码（换句话说，X是一个超码）
* 所有非主属性对每一个码都是完全函数依赖，
   即, 若R∈BCNF, 则R∈2NF。
* 所有的主属性对每一个不包含它的码也是完全函数依赖。
* 没有任何属性完全函数依赖于非码的任何一组属性。
* 若R∈BCNF, 则必有R∈3NF; 反之不一定成立


> ### 铛铛铛！！！敲黑板，候选码的求解算法
> 以下算法会涉及到求属性集的闭包，[函数依赖集和属性集闭包传送阵](http://www.jianshu.com/p/78d16f97ef0c)

#### 设关系模式R<U, F>
1. 将R的所有属性**分为 L、 R、N和 LR四类**，并令**X代表L、N两类**，**Y代表LR类**。
    * L类: **仅**出现在F的函数依赖**左**部的属性；
    * R类: **仅**出现在F的函数依赖**右**部的属性；
    * N类: 在F的函数依赖**左右**两边**都不出现**的属性；
    * LR类:在F的函数依赖**左右**两边**都出现**的属性 。
2. **求属性集闭包**X<sup>+</sup>，若 X<sup>+</sup>包含了R的全部属性则X即为R的唯一候选码, **转5**;
3.  否则, **在Y中取一属性A**，求属性集闭包(XA)+，若(XA)+包含了R的全部属性，则**转4**；否则，调换一属性反复进行这一过程，直到试完所有Y中的属性。
4.  如果已找出了所有的候选码，则转(5)；否则在Y中依次取2个、3个、…属性，求X与它们的属性集闭包，直到其闭包包含R的全部属性。
5.  停止，输出结果。

* 例1： 设关系模式R(A, B, C, D), 其函数依赖集：
            F={D→B, B→D, AD→B, AC→D}，求R的所有候选码。
解: L类: A, C
     R类:
     N类:
     LR类: B, D
因为(AC)<sub>F</sub><sup>+</sup>=ACDB，所以AC是R的唯一候选码


* 例2：设关系模式R(A, B, C, D, E, P), 其函数依赖集：
         F={A→D, E→D, D→B, BC→D, DC→A}，求R的所有候选码。
解:  L类: C, E
R类:
N类: P
LR类: A, B, D
因为(CEP)F+=CEPDBA，所以CEP是R的唯一候选码。


* 例3： 设关系模式R(S, D, I, B, O, Q), 其函数依赖集:
          F = { S→D, I→B, B→O, O→Q, Q→I }，求R的所有候选码。
解: L类(S);  R类(D)  ; N类(无) ;  LR类(I, B, O, Q)
        因为S+=SD, 所以S不是R的候选码；
        因为(SI)+=SIDBOQ，所以SI是一个候选码；
        因为(SB)+=SBDOQI，所以SB也是一个候选码；
        因为(SO)+=SODQIB，所以SO也是一个候选码；
        因为(SQ)+=SQDIBO，所以SQ也是一个候选码。
